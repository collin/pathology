# Pathology

### The scientific study of the nature of ~~disease~~ JavaScript and its causes, processes, development, and consequences.

Ember.js has AWESOME toString() support for objects. And I wanted some of that magic sauce. But I'm not ready to commit to Ember.js for the project I'm working on, there is just too much existing code.

Right now this only really does the following:

### Pretty toString on objects.

```coffee
# Pathology = require "pathology"

# One ugly-ish thing about pathology.
# You've got to explicitly name your top-level
# namespaces. Unlike Ember, Pathology isn't going
# to go rooting around the global namespace looking
# for your objects.
Root = Pathology.Namespace.create("Root")

# However, Pathology doesn't need you to explicitly name
# your further nested namespaces. As long as all your objects
# are connected to a root level Namespace.
# You can even reference your objects elsewhere for convenience.
Subspace = Root.Subspace = Pathology.Namespace.create()

# Pathology provides a basic Object with extend/create semantics.
Subspace.Thing = Pathology.Object.extend
  initialize: (@properties={}) ->
something = Subspace.Thing.create(property: "value")

# And this all comes together for the final awesome-sauce.
puts Subspace.Thing.toString()
# => Root.Subspace.Thing
puts something.toString()
# => <Root.Subspace.Thing:p-9>
puts something.noSuchMethod()
# => TypeError: Object <Root.Subspace.Thing:p-9> has no method 'notAMethod'
```
# Rejoice in your debugging :D

### Mixins
Pathology includes a simplistic mixin system. (no _super here, sorry)

Use it more or less like this

```coffee
Root.Mixable = Pathology.Object.extend()
Root.Mixer = Pathology.Mixin.create
  included: ->
    puts "included in Root.Mixable? ", this is Root.Mixable

  static:
    staticKey: "Static Value"

  instance:
    instanceKey: "Instance Value"

Root.Mixer.extends(Root.Mixable)
# "included in Root.Mixable? true"
Root.Mixer.staticKey
# => "Static Value"
Root.Mixer.create().instanceKey
# => "Instance Value"
Root.Mixer.extended(Root.Mixable)
# => true
```

### Delegation
Pathology Objects may define method and property delegation.
Defining delegates looks like this:
```coffee
Awesome = Root.Awesome = Pathology.Object.extend
  target:
    foo: "foo"
    bar: -> "bar"

  other: ->
    return biz: "biz", baz: -> "baz"

Awesome.delegate "foo", "bar", to: "target"
Awesome.delegate "biz", "baz", to: "other"
```

With this delegation setup we can call the following methods on an Awesom object.
Pathology delegates will inspect the objects that are in the delegation chain
and call methods if they are in the chain.

Here are some calls to delegate methods and the equivalant manual access.

```coffee
awesome = Awesome.create()
# awesome.foo() is the same as awesome.target.foo
awesome.foo()
# => "foo"
# awesome.bar() is the same as awesome.target.bar()
awesome.bar()
# => "bar"
# awesome.biz() is the same as awesome.other().biz
awesome.biz()
# => "biz"
# awesome.baz() is the same as awesome.other().baz()
awesome.baz()
# => "baz"
```

# Changelog

## 0.3.0
* added a delegate mixin

## 0.2.0
* mixin system

## 0.1.0
* basic object system
