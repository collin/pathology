# Pathology

### The scientific study of the nature of ~~disease~~ JavaScript and its causes, processes, development, and consequences.

```coffee
puts = console.log
```

Ember.js has AWESOME toString() support for objects. And I wanted some of that magic sauce. But I'm not ready to commit to Ember.js for the project I'm working on, there is just too much existing code.

Right now this only really does the following:

### Pretty toString on objects.

```coffee
# Pathology = require "pathology"

# One ugly-ish thing about pathology.
# You've got to explicitly name your top-level
# namespaces. Unlike Ember, Pathology isn't going
# to go rooting around the global namespace looking
# for your objects.
Root = Pathology.Namespace.create("Root")

# However, Pathology doesn't need you to explicitly name
# your further nested namespaces. As long as all your objects
# are connected to a root level Namespace.
# You can even reference your objects elsewhere for convenience.
Subspace = Root.Subspace = Pathology.Namespace.create()

# Pathology provides a basic Object with extend/create semantics.
Subspace.Thing = Pathology.Object.extend
  initialize: (@properties={}) ->
something = Subspace.Thing.create(property: "value")

# And this all comes together for the final awesome-sauce.
puts Subspace.Thing.toString()
# => Root.Subspace.Thing
puts something.toString()
# => <Root.Subspace.Thing:p-9>
puts something.noSuchMethod()
# => TypeError: Object <Root.Subspace.Thing:p-9> has no method 'notAMethod'
```

Stack trace pulled from Taxi, an event library built on Pathology:
(slightly doctored for visual appeal to show off toString goodness)

```
Error: Rejoice in your debugging! :D
  at                                          (taxi/lib/taxi.coffee:88:17)
  at     Array.map                            (native)
  at                                          (taxi/node_modules/underscore/underscore.js:95:56)
  at     Taxi.Path.readToSegment              (taxi/lib/taxi.coffee:86:35)
  at     Taxi.Segment.readSourceProperties    (taxi/lib/taxi.coffee:140:48)
  at     Taxi.Segment.rebind                  (taxi/lib/taxi.coffee:117:12)
  at     Taxi.Path.addSegment                 (taxi/lib/taxi.coffee:69:16)
  at     NS.Evented.bindPath                  (taxi/lib/taxi.coffee:173:17)
  at     Object.<anonymous>                   (taxi/test/taxi.coffee:140:21)
  at     Object.<anonymous>                   (nodeunit/lib/core.js:233:16)
```

### Inheritable Attributes
This one is inspired by an old feature of Rails.

Sometimes you're making a configuration on a class that you want to propagate
to all its subclasses. And you also want to extend that configuration in
the subclasses. An example might be a list of attributes. With ineritable attributes
you might implement this:

```coffee
Model = Root.Model = Pathology.Object.extend
Model.pushInheritableItem "fields", "id"
Model.pushInheritableItem "fields", "name"

Describable = Model.Describable = Model.extend()
Describable.pushInheritableItem "fields", "description"

puts Model.fields
# => ["id", "name"]
puts Describable.fields
# => ["id", "name", "description"]
```

This can be handy.

There are three methods for dealing with inheritable attributes:

* writeInheritableAttr(slot, value)
* writeInheritableValue(slot, key, value)
* pushInheritableItem(slot, item)

Use them like so:

```coffee
Model.writeInheritableAttr("slot", "value")
puts Describable.slot
# => "value"
Model.writeInheritableValue("family", "name", "Stanislov")
puts Describable.family.name
# => "Stasilov"
Model.pushInheritableItem("fields", "extras")
puts Describable.fields
# => ["id", "name", "description", "extras"]
```

With writeInheritableValue, and pushInheritableitem, when you add a value to a slot
on a child class, the value does not appear on the parent.

### Properties

Pathology allows you to create properties on your objects.

Properties are defined on a constructor. Under the hood properties
are stored in an Inheritable Attribute, so ancestors will have the
properties of their parents.

```coffee
Root.Subspace.Thing.property('aProperty')
```

And property configurations are reflected.

```coffee
Root.Subspace.Thing.properties.aProperty
# => <Pathology.Property:p-23>
```

Property instances are created after the initialize method.

```coffee
Root.Subspace.Thing.create().aProperty
# => <Pathology.Property.Instance:p-24>
```

##### propertiesThatCouldBe
A Pathology object has a special accessor for properties: 'propertiesThatCouldBe'
This iterates over all properties of the object and tests their 'couldBe' method
against a test value. For the vanilla Pathology.Property this is just a 
check against the property name.


##### Extending Pathology.Property
Pathology.Property follows a simple interface. The core property implementation
is the following:

```coffee
Property = Pathology.Object.extend
  Instance: Pathology.Object.extend
    get: -> @value
    set: (value) -> @value = value

  initialize: (@name, @_constructor) ->
    @_constructor.writeInheritableValue 'properties', @name, this

  couldBe: (test) ->
    return true if test is @name
    false

  instance: -> @Instance.create()

```

If you extend Pathology.Property you will most likely be working on the
Instance. See this example from Taxi, an event binding library,

```coffee
Taxi.Property = Pathology.Property.extend
  Instance: Pathology.Property.Instance.extend
    set: (value) ->
      return value if value is @value
      @value = value
      @trigger "change"
      value
```

### Mixins
Pathology includes a simplistic mixin system. (no _super here, sorry)

Use it more or less like this

```coffee
Root.Mixable = Pathology.Object.extend()
Root.Mixer = Pathology.Mixin.create
  included: ->
    puts "included in Root.Mixable? ", this is Root.Mixable

  static:
    staticKey: "Static Value"

  instance:
    instanceKey: "Instance Value"

Root.Mixer.extends(Root.Mixable)
# "included in Root.Mixable? true"
Root.Mixer.staticKey
# => "Static Value"
Root.Mixer.create().instanceKey
# => "Instance Value"
Root.Mixer.extended(Root.Mixable)
# => true
```

### Delegation
Pathology Objects may define method and property delegation.
Defining delegates looks like this:

```coffee
Awesome = Root.Awesome = Pathology.Object.extend
  target:
    foo: "foo"
    bar: -> "bar"

  other: ->
    return biz: "biz", baz: -> "baz"

Awesome.delegate "foo", "bar", to: "target"
Awesome.delegate "biz", "baz", to: "other"
```

With this delegation setup we can call the following methods on an Awesom object.
Pathology delegates will inspect the objects that are in the delegation chain
and call methods if they are in the chain.

Here are some calls to delegate methods and the equivalant manual access.

```coffee
awesome = Awesome.create()
# awesome.foo() is the same as awesome.target.foo
awesome.foo()
# => "foo"
# awesome.bar() is the same as awesome.target.bar()
awesome.bar()
# => "bar"
# awesome.biz() is the same as awesome.other().biz
awesome.biz()
# => "biz"
# awesome.baz() is the same as awesome.other().baz()
awesome.baz()
# => "baz"
```

# Changelog

## 0.2.0
* mixin system
* added a delegate mixin
* inheritable attributes
* pathology properties
* turned constructors into Functions, like god intended

## 0.1.0
* basic object system


